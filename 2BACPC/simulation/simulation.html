<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulateur : Pendule de Torsion</title>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        body { margin: 0; font-family: 'Segoe UI', sans-serif; overflow: hidden; background: #121212; color: white; }
        
        /* Panneau de Contrôle */
        #ui-panel {
            position: absolute; top: 10px; left: 10px; bottom: 10px;
            width: 360px; background: rgba(20, 20, 20, 0.95);
            padding: 20px; border-right: 1px solid #444;
            box-shadow: 5px 0 15px rgba(0,0,0,0.5);
            overflow-y: auto; display: flex; flex-direction: column;
            border-radius: 8px; z-index: 10;
        }

        h2 { color: #4facfe; margin: 0 0 15px 0; font-size: 20px; border-bottom: 1px solid #444; padding-bottom: 10px; }
        h3 { font-size: 14px; color: #aaa; margin-top: 20px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }

        .control-group { margin-bottom: 15px; background: #1e1e1e; padding: 12px; border-radius: 6px; border: 1px solid #333; }
        label { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 8px; color: #ddd; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #4facfe; }
        
        .val-disp { font-weight: bold; color: #00f260; }
        .unit { font-size: 0.8em; color: #888; font-weight: normal;}

        /* Boite de formule et résultats */
        .formula-box {
            background: #222; padding: 15px; border-radius: 6px; margin-top: 10px;
            font-family: 'Courier New', monospace; font-size: 14px;
            border-left: 4px solid #4facfe; text-align: center;
        }
        .result-row { display: flex; justify-content: space-between; margin-top: 8px; font-size: 13px; }
        .highlight { color: #ff9800; font-weight: bold; font-size: 16px; }

        /* Boutons */
        .btn-row { display: flex; gap: 10px; margin-top: 15px; }
        button {
            flex: 1; padding: 12px; border: none; border-radius: 5px;
            font-weight: bold; cursor: pointer; transition: 0.2s; color: white;
        }
        #btn-twist { background: #4facfe; }
        #btn-twist:hover { background: #00c6fb; }
        #btn-stop { background: #f44336; }

        /* Graphique */
        #chart-container {
            height: 160px; background: #1a1a1a; margin-top: 20px;
            padding: 5px; border-radius: 5px; border: 1px solid #333;
        }

        #canvas-container { width: 100%; height: 100vh; }
    </style>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-panel">
        <h2>Pendule de Torsion</h2>

        <div class="formula-box">
            <div>T₀ = 2π √(J / C)</div>
        </div>

        <h3>1. Moment d'Inertie (J)</h3>
        <div class="control-group">
            <div style="font-size:11px; color:#aaa; margin-bottom:5px;">Modification de la répartition des masses</div>
            <label>Distance (r) <span id="val-r" class="val-disp">1.5 <span class="unit">m</span></span></label>
            <input type="range" id="inp-r" min="0.2" max="2.5" step="0.1" value="1.5">
            
            <div class="result-row">
                <span>J calculé (2·m·r²) :</span>
                <span id="calc-j" style="color:#aaa;">-- kg·m²</span>
            </div>
        </div>

        <h3>2. Constante de Torsion (C)</h3>
        <div class="control-group">
            <div style="font-size:11px; color:#aaa; margin-bottom:5px;">Rigidité du fil</div>
            <label>Constante C <span id="val-c" class="val-disp">5.0 <span class="unit">N·m/rad</span></span></label>
            <input type="range" id="inp-c" min="1" max="20" step="1" value="5">
        </div>

        <div class="formula-box" style="border-left-color: #ff9800;">
            Période Propre T₀ :<br>
            <span id="disp-t0" class="highlight">-- s</span>
        </div>

        <div class="btn-row">
            <button id="btn-twist">Tordre & Lâcher</button>
            <button id="btn-stop">Arrêter</button>
        </div>

        <div id="chart-container">
            <canvas id="oscGraph"></canvas>
        </div>
        <div style="font-size:10px; text-align:center; color:#666; margin-top:5px;">Angle θ en fonction du temps</div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION CHART.JS ---
        const ctx = document.getElementById('oscGraph').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Angle θ (rad)',
                    data: [],
                    borderColor: '#4facfe',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { display: false },
                    y: { grid: { color: '#333' }, ticks: { color: '#888' }, min: -1.5, max: 1.5 }
                },
                plugins: { legend: { display: false } }
            }
        });

        // --- CONFIGURATION THREE.JS ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x181818);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 12);
        camera.lookAt(0, -2, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lumières
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const spotLight = new THREE.SpotLight(0xffffff, 100);
        spotLight.position.set(5, 10, 5);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // --- OBJETS 3D ---

        // Support plafond
        const support = new THREE.Mesh(new THREE.BoxGeometry(4, 0.2, 4), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        support.position.y = 5;
        scene.add(support);

        // Le Fil de Torsion
        const wireGeo = new THREE.CylinderGeometry(0.05, 0.05, 5);
        const wireMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.8, roughness: 0.2 });
        const wire = new THREE.Mesh(wireGeo, wireMat);
        wire.position.y = 2.5; // Milieu du fil (de 0 à 5)
        scene.add(wire);

        // Groupe Pendule (Barre + Masses) qui va tourner
        const pendulumGroup = new THREE.Group();
        scene.add(pendulumGroup);

        // Barre horizontale
        const barGeo = new THREE.BoxGeometry(6, 0.2, 0.4);
        const barMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const bar = new THREE.Mesh(barGeo, barMat);
        pendulumGroup.add(bar);

        // Repère Visuel (Flèche) pour voir la rotation
        const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0.5,0), 1.5, 0xffff00);
        pendulumGroup.add(arrowHelper);

        // Masses (Sphères)
        const sphereGeo = new THREE.SphereGeometry(0.6, 32, 32);
        const sphereMat = new THREE.MeshStandardMaterial({ color: 0xff4444, metalness: 0.5, roughness: 0.1 });
        
        const massL = new THREE.Mesh(sphereGeo, sphereMat);
        const massR = new THREE.Mesh(sphereGeo, sphereMat);
        massL.castShadow = true; massR.castShadow = true;
        pendulumGroup.add(massL);
        pendulumGroup.add(massR);

        // Sol (Décoratif)
        const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        grid.position.y = -3;
        scene.add(grid);

        // --- PHYSIQUE & LOGIQUE ---

        const params = {
            r: 1.5,     // Distance des masses à l'axe (m)
            m: 2.0,     // Masse de chaque sphère (kg) (Fixe pour simplification)
            C: 5.0,     // Constante de torsion (N.m/rad)
            theta0: 1.0 // Angle initial (rad)
        };

        let state = {
            theta: 0,   // Angle actuel
            omega: 0,   // Vitesse angulaire
            alpha: 0,   // Accélération angulaire
            running: false,
            t: 0
        };

        const elR = document.getElementById('inp-r');
        const elC = document.getElementById('inp-c');
        const txtR = document.getElementById('val-r');
        const txtC = document.getElementById('val-c');
        const txtJ = document.getElementById('calc-j');
        const txtT0 = document.getElementById('disp-t0');

        // Calcul du Moment d'Inertie J
        // On néglige la barre pour l'exercice pédagogique, on se concentre sur les masses ponctuelles.
        // J = Sum(m * r^2) = m*r² + m*r² = 2*m*r²
        function getInertia() {
            // On ajoute une petite constante (0.1) pour la barre pour éviter J=0 si r=0
            return 0.1 + (2 * params.m * (params.r * params.r)); 
        }

        function updateParams() {
            params.r = parseFloat(elR.value);
            params.C = parseFloat(elC.value);

            txtR.innerHTML = params.r.toFixed(1) + ' <span class="unit">m</span>';
            txtC.innerHTML = params.C.toFixed(1) + ' <span class="unit">N·m/rad</span>';

            // Mise à jour visuelle 3D
            massL.position.x = -params.r;
            massR.position.x = params.r;

            // Changement visuel épaisseur fil selon rigidité C
            const thickness = 0.02 + (params.C / 20) * 0.08;
            wire.scale.set(thickness/0.05, 1, thickness/0.05);

            // Calculs Physique
            const J = getInertia();
            txtJ.innerText = J.toFixed(2) + " kg·m²";

            // Période T0
            const T0 = 2 * Math.PI * Math.sqrt(J / params.C);
            txtT0.innerText = T0.toFixed(2) + " s";
        }

        elR.addEventListener('input', updateParams);
        elC.addEventListener('input', updateParams);

        document.getElementById('btn-twist').addEventListener('click', () => {
            state.running = true;
            state.theta = params.theta0;
            state.omega = 0;
            state.t = 0;
            // Reset Graph
            chart.data.labels = [];
            chart.data.datasets[0].data = [];
            chart.update();
        });

        document.getElementById('btn-stop').addEventListener('click', () => {
            state.running = false;
            state.theta = 0;
            state.omega = 0;
            pendulumGroup.rotation.y = 0;
        });

        // --- BOUCLE D'ANIMATION ---
        const dt = 0.016; // Pas de temps fixe
        let chartCounter = 0;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (state.running) {
                const J = getInertia();
                
                // Equation différentielle : J * alpha + C * theta = 0
                // => alpha = - (C * theta) / J
                
                state.alpha = - (params.C * state.theta) / J;
                
                // Intégration (Euler semi-implicite)
                state.omega += state.alpha * dt;
                
                // Ajout d'un très léger amortissement pour réalisme (optionnel)
                state.omega *= 0.999; 
                
                state.theta += state.omega * dt;
                state.t += dt;

                // Rotation 3D
                pendulumGroup.rotation.y = state.theta;

                // Graphique
                chartCounter++;
                if (chartCounter > 4) {
                    chart.data.labels.push('');
                    chart.data.datasets[0].data.push(state.theta);
                    if(chart.data.labels.length > 100) {
                        chart.data.labels.shift();
                        chart.data.datasets[0].data.shift();
                    }
                    chart.update('none');
                    chartCounter = 0;
                }
            } else {
                // Si à l'arrêt, on permet de visualiser l'angle si on voulait...
                // Mais ici on reset à 0
                pendulumGroup.rotation.y = THREE.MathUtils.lerp(pendulumGroup.rotation.y, 0, 0.1);
            }

            // Torsion visuelle du fil (optionnel, shader complexe, ici simple rotation)
            // Le fil reste fixe, la barre tourne.
            
            renderer.render(scene, camera);
        }

        // Init
        updateParams();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>